From 4cab03a500b4fa3df96f582252eebbc06cd2de8a Mon Sep 17 00:00:00 2001
From: Ricardo Cerqueira <github@cerqueira.org>
Date: Thu, 22 Nov 2012 17:47:31 +0100
Subject: [PATCH 1/7] RIL: Make RIL subclassable

Change-Id: I9144ef279ca9c8cb9e657a28342f0f4cb3e7debd

From: Pawit Pornkitprasan <p.pawit@gmail.com>
Date: Thu, 22 Nov 2012 19:01:13 +0100
Subject: [PATCH] telephony: Use reflection to create command interface (RIL class)

Change-Id: Icdc02eaa74b89dbde4ddfb989cc62481d6423312

PhoneFactory: fall back to default RIL if custom RIL Class fails

If the ro.telephony.ril_class property is set to an invalid class it will cause
Phone to repeatedly FC and make the device unuseable. This allows it to handle the
exceptions gracefully and fall back on the default RIL.

Change-Id: Ic9c309aff173de5267aa7ef633bfff87243f24fd

PhoneFactory: Block radio init if the device's custom class can't be used

Trap the initialization process in a 10 second error loop. The device
will be normally usable, and have a dead radio. The radio log buffer
will have the full stack dump explaining what went wrong during the
custom class instantiation.

Change-Id: Id47d51737a9fb78e6d43a179ba304b1ba03c4219

From: Ricardo Cerqueira <cyanogenmod@cerqueira.org>
Date: Thu, 22 Nov 2012 06:02:18 +0000
Subject: [PATCH] Allow a device to include its own RIL subclass

For cases where a single device needs a subclass, there's no need to
pollute the common core with it: just stick it in the device's own
repository, and add something like
"BOARD_RIL_CLASS := ../../../device/manuf/model/ril/" to the BoardConfig

Change-Id: I9d01ceb6e5587382eb216341e2e373ec0c52848f

From: Pawit Pornkitprasan <p.pawit@gmail.com>
Date: Sat, 8 Mar 2014 19:35:17 +0700
Subject: [PATCH] RIL: mark mInstanceId as protected

To use in RIL subclasses

Change-Id: I4ab1ea79079e3b03670b1e985f7a574df1f16658

From: Dan Pasanen <dan.pasanen@gmail.com>
Date: Mon, 10 Nov 2014 23:50:17 -0600
Subject: [PATCH] RIL: set responseCellInfoList protected to override in sub classes

Change-Id: Ibbbee0c1a59ab2be6b71fc2f70c6279314b55d6e

From: JustArchi <JustArchi@JustArchi.net>
Date: Sat, 2 May 2015 06:17:49 +0200
Subject: [PATCH] RIL: Make some methods protected

This is required for some RIL subclasses, if they want to use them

Change-Id: I59f0148be0f49b4ee2997a669e74a61c2f6a8069

From: Varun Chitre <varun.chitre15@gmail.com>
Date: Sat, 16 May 2015 02:28:40 -0400
Subject: [PATCH] RIL : allow RILReceiver to be overridden

Change-Id: If23252901073a1658fa965e14cd7188ce39397f8
Signed-off-by: Varun Chitre <varun.chitre15@gmail.com>

Telephony: Allow more RIL methods to be overridden

Change-Id: I7a18e16256da5b2205910d894008044a6b9478ae
Signed-off-by: Varun Chitre <varun.chitre15@gmail.com>

Change-Id: Id43b0fb43ad7f19c2e4b2a6af5590f7b3a17761e
---
 Android.mk                                         |   5 +
 .../android/internal/telephony/PhoneFactory.java   |  29 +++++-
 src/java/com/android/internal/telephony/RIL.java   | 116 +++++++++++----------
 3 files changed, 92 insertions(+), 58 deletions(-)

diff --git a/Android.mk b/Android.mk
index 449faa0..d312fec 100644
--- a/Android.mk
+++ b/Android.mk
@@ -25,6 +25,11 @@ LOCAL_SRC_FILES := $(call all-java-files-under, src/java) \
 	$(call all-logtags-files-under, src/java)
 
 LOCAL_JAVA_LIBRARIES := voip-common ims-common
+
+ifneq ($(BOARD_RIL_CLASS),)
+LOCAL_SRC_FILES += $(call find-other-java-files,$(BOARD_RIL_CLASS))
+endif
+
 LOCAL_MODULE_TAGS := optional
 LOCAL_MODULE := telephony-common
 
diff --git a/src/java/com/android/internal/telephony/PhoneFactory.java b/src/java/com/android/internal/telephony/PhoneFactory.java
index aec3d8e..ee84855 100644
--- a/src/java/com/android/internal/telephony/PhoneFactory.java
+++ b/src/java/com/android/internal/telephony/PhoneFactory.java
@@ -46,6 +46,7 @@ import com.android.internal.util.IndentingPrintWriter;
 
 import java.io.FileDescriptor;
 import java.io.PrintWriter;
+import java.lang.reflect.Constructor;
 import java.util.HashMap;
 
 /**
@@ -140,6 +141,8 @@ public class PhoneFactory {
                 sPhones = new Phone[numPhones];
                 sCommandsInterfaces = new RIL[numPhones];
                 sTelephonyNetworkFactories = new TelephonyNetworkFactory[numPhones];
+                String sRILClassname = SystemProperties.get("ro.telephony.ril_class", "RIL").trim();
+                Rlog.i(LOG_TAG, "RILClassname is " + sRILClassname);
 
                 for (int i = 0; i < numPhones; i++) {
                     // reads the system properties and makes commandsinterface
@@ -147,8 +150,20 @@ public class PhoneFactory {
                     networkModes[i] = RILConstants.PREFERRED_NETWORK_MODE;
 
                     Rlog.i(LOG_TAG, "Network Mode set to " + Integer.toString(networkModes[i]));
-                    sCommandsInterfaces[i] = new RIL(context, networkModes[i],
-                            cdmaSubscription, i);
+                    // Use reflection to construct the RIL class (defaults to RIL)
+                    try {
+                        sCommandsInterfaces[i] = instantiateCustomRIL(
+                                                     sRILClassname, context, networkModes[i], cdmaSubscription, i);
+                    } catch (Exception e) {
+                        // 6 different types of exceptions are thrown here that it's
+                        // easier to just catch Exception as our "error handling" is the same.
+                        // Yes, we're blocking the whole thing and making the radio unusable. That's by design.
+                        // The log message should make it clear why the radio is broken
+                        while (true) {
+                            Rlog.e(LOG_TAG, "Unable to construct custom RIL class", e);
+                            try {Thread.sleep(10000);} catch (InterruptedException ie) {}
+                        }
+                    }
                 }
                 Rlog.i(LOG_TAG, "Creating SubscriptionController");
                 SubscriptionController.init(context, sCommandsInterfaces);
@@ -232,6 +247,16 @@ public class PhoneFactory {
         }
     }
 
+    private static <T> T instantiateCustomRIL(String sRILClassname, Context context,
+                                        int networkMode, int cdmaSubscription, Integer instanceId)
+                                        throws Exception {
+        Class<?> clazz = Class.forName("com.android.internal.telephony." + sRILClassname);
+        Constructor<?> constructor = clazz.getConstructor(
+                                            Context.class, int.class, int.class, Integer.class);
+        return (T) clazz.cast(constructor.newInstance(
+                                            context, networkMode, cdmaSubscription, instanceId));
+    }
+
     public static Phone getDefaultPhone() {
         synchronized (sLockProxyPhones) {
             if (!sMadeDefaults) {
diff --git a/src/java/com/android/internal/telephony/RIL.java b/src/java/com/android/internal/telephony/RIL.java
index 8d042d8..699cf50 100644
--- a/src/java/com/android/internal/telephony/RIL.java
+++ b/src/java/com/android/internal/telephony/RIL.java
@@ -238,7 +238,7 @@ class RILRequest {
  *
  * {@hide}
  */
-public final class RIL extends BaseCommands implements CommandsInterface {
+public class RIL extends BaseCommands implements CommandsInterface {
     static final String RILJ_LOG_TAG = "RILJ";
     // Have a separate wakelock instance for Ack
     static final String RILJ_ACK_WAKELOCK_NAME = "RILJ_ACK_WL";
@@ -295,7 +295,7 @@ public final class RIL extends BaseCommands implements CommandsInterface {
     // When we are testing emergency calls
     AtomicBoolean mTestingEmergencyCall = new AtomicBoolean(false);
 
-    private Integer mInstanceId;
+    protected Integer mInstanceId;
 
     private TelephonyEventLog mEventLog;
 
@@ -595,10 +595,10 @@ public final class RIL extends BaseCommands implements CommandsInterface {
         return messageLength;
     }
 
-    class RILReceiver implements Runnable {
+    protected class RILReceiver implements Runnable {
         byte[] buffer;
 
-        RILReceiver() {
+        protected RILReceiver() {
             buffer = new byte[RIL_MAX_COMMAND_BYTES];
         }
 
@@ -762,7 +762,7 @@ public final class RIL extends BaseCommands implements CommandsInterface {
             riljLog("Not starting RILReceiver: wifi-only");
         } else {
             riljLog("Starting RILReceiver" + mInstanceId);
-            mReceiver = new RILReceiver();
+            mReceiver = createRILReceiver();
             mReceiverThread = new Thread(mReceiver, "RILReceiver" + mInstanceId);
             mReceiverThread.start();
 
@@ -784,6 +784,10 @@ public final class RIL extends BaseCommands implements CommandsInterface {
         tdc.registerRIL(this);
     }
 
+    protected RILReceiver createRILReceiver() {
+        return new RILReceiver();
+    }
+
     //***** CommandsInterface implementation
 
     @Override
@@ -2397,7 +2401,7 @@ public final class RIL extends BaseCommands implements CommandsInterface {
         }
     }
 
-    private void sendScreenState(boolean on) {
+    protected void sendScreenState(boolean on) {
         RILRequest rr = RILRequest.obtain(RIL_REQUEST_SCREEN_STATE, null);
         rr.mParcel.writeInt(1);
         rr.mParcel.writeInt(on ? 1 : 0);
@@ -2416,7 +2420,7 @@ public final class RIL extends BaseCommands implements CommandsInterface {
         updateScreenState();
    }
 
-    private RadioState getRadioStateFromInt(int stateInt) {
+    protected RadioState getRadioStateFromInt(int stateInt) {
         RadioState state;
 
         /* RIL_RadioState ril.h */
@@ -2432,7 +2436,7 @@ public final class RIL extends BaseCommands implements CommandsInterface {
         return state;
     }
 
-    private void switchToRadioState(RadioState newState) {
+    protected void switchToRadioState(RadioState newState) {
         setRadioState(newState);
     }
 
@@ -2529,7 +2533,7 @@ public final class RIL extends BaseCommands implements CommandsInterface {
         }
     }
 
-    private void
+    protected void
     send(RILRequest rr) {
         Message msg;
 
@@ -2544,7 +2548,7 @@ public final class RIL extends BaseCommands implements CommandsInterface {
         msg.sendToTarget();
     }
 
-    private void
+    protected void
     processResponse (Parcel p) {
         int type;
 
@@ -2585,7 +2589,7 @@ public final class RIL extends BaseCommands implements CommandsInterface {
      * @param error is the RIL_Errno sent back
      * @param loggable true means to print all requests in mRequestList
      */
-    private void clearRequestList(int error, boolean loggable) {
+    protected void clearRequestList(int error, boolean loggable) {
         RILRequest rr;
         synchronized (mRequestList) {
             int count = mRequestList.size();
@@ -2609,7 +2613,7 @@ public final class RIL extends BaseCommands implements CommandsInterface {
         }
     }
 
-    private RILRequest findAndRemoveRequestFromList(int serial) {
+    protected RILRequest findAndRemoveRequestFromList(int serial) {
         RILRequest rr = null;
         synchronized (mRequestList) {
             rr = mRequestList.get(serial);
@@ -2621,7 +2625,7 @@ public final class RIL extends BaseCommands implements CommandsInterface {
         return rr;
     }
 
-    private RILRequest
+    protected RILRequest
     processSolicited (Parcel p, int type) {
         int serial, error;
         boolean found = false;
@@ -2899,7 +2903,7 @@ public final class RIL extends BaseCommands implements CommandsInterface {
         return rr;
     }
 
-    private RadioCapability makeStaticRadioCapability() {
+    protected RadioCapability makeStaticRadioCapability() {
         // default to UNKNOWN so we fail fast.
         int raf = RadioAccessFamily.RAF_UNKNOWN;
 
@@ -2998,7 +3002,7 @@ public final class RIL extends BaseCommands implements CommandsInterface {
         return s;
     }
 
-    private void
+    protected void
     processUnsolicited (Parcel p, int type) {
         int response;
         Object ret;
@@ -3513,7 +3517,7 @@ public final class RIL extends BaseCommands implements CommandsInterface {
      *
      * @param rilVer is the version of the ril or -1 if disconnected.
      */
-    private void notifyRegistrantsRilConnectionChanged(int rilVer) {
+    protected void notifyRegistrantsRilConnectionChanged(int rilVer) {
         mRilVersion = rilVer;
         if (mRilConnectedRegistrants != null) {
             mRilConnectedRegistrants.notifyRegistrants(
@@ -3521,7 +3525,7 @@ public final class RIL extends BaseCommands implements CommandsInterface {
         }
     }
 
-    private Object
+    protected Object
     responseInts(Parcel p) {
         int numInts;
         int response[];
@@ -3537,7 +3541,7 @@ public final class RIL extends BaseCommands implements CommandsInterface {
         return response;
     }
 
-    private Object
+    protected Object
     responseFailCause(Parcel p) {
         LastCallFailCause failCause = new LastCallFailCause();
         failCause.causeCode = p.readInt();
@@ -3547,12 +3551,12 @@ public final class RIL extends BaseCommands implements CommandsInterface {
         return failCause;
     }
 
-    private Object
+    protected Object
     responseVoid(Parcel p) {
         return null;
     }
 
-    private Object
+    protected Object
     responseCallForward(Parcel p) {
         int numInfos;
         CallForwardInfo infos[];
@@ -3575,7 +3579,7 @@ public final class RIL extends BaseCommands implements CommandsInterface {
         return infos;
     }
 
-    private Object
+    protected Object
     responseSuppServiceNotification(Parcel p) {
         SuppServiceNotification notification = new SuppServiceNotification();
 
@@ -3588,7 +3592,7 @@ public final class RIL extends BaseCommands implements CommandsInterface {
         return notification;
     }
 
-    private Object
+    protected Object
     responseCdmaSms(Parcel p) {
         SmsMessage sms;
         sms = SmsMessage.newFromParcel(p);
@@ -3596,7 +3600,7 @@ public final class RIL extends BaseCommands implements CommandsInterface {
         return sms;
     }
 
-    private Object
+    protected Object
     responseString(Parcel p) {
         String response;
 
@@ -3605,7 +3609,7 @@ public final class RIL extends BaseCommands implements CommandsInterface {
         return response;
     }
 
-    private Object
+    protected Object
     responseStrings(Parcel p) {
         int num;
         String response[];
@@ -3615,7 +3619,7 @@ public final class RIL extends BaseCommands implements CommandsInterface {
         return response;
     }
 
-    private Object
+    protected Object
     responseRaw(Parcel p) {
         int num;
         byte response[];
@@ -3625,7 +3629,7 @@ public final class RIL extends BaseCommands implements CommandsInterface {
         return response;
     }
 
-    private Object
+    protected Object
     responseSMS(Parcel p) {
         int messageRef, errorCode;
         String ackPDU;
@@ -3640,7 +3644,7 @@ public final class RIL extends BaseCommands implements CommandsInterface {
     }
 
 
-    private Object
+    protected Object
     responseICC_IO(Parcel p) {
         int sw1, sw2;
         Message ret;
@@ -3658,7 +3662,7 @@ public final class RIL extends BaseCommands implements CommandsInterface {
         return new IccIoResult(sw1, sw2, s);
     }
 
-    private Object
+    protected Object
     responseICC_IOBase64(Parcel p) {
         int sw1, sw2;
         Message ret;
@@ -3677,7 +3681,7 @@ public final class RIL extends BaseCommands implements CommandsInterface {
                 ? android.util.Base64.decode(s, android.util.Base64.DEFAULT) : (byte[]) null);
     }
 
-    private Object
+    protected Object
     responseIccCardStatus(Parcel p) {
         IccCardApplicationStatus appStatus;
 
@@ -3709,7 +3713,7 @@ public final class RIL extends BaseCommands implements CommandsInterface {
         return cardStatus;
     }
 
-    private Object
+    protected Object
     responseSimRefresh(Parcel p) {
         IccRefreshResponse response = new IccRefreshResponse();
 
@@ -3719,7 +3723,7 @@ public final class RIL extends BaseCommands implements CommandsInterface {
         return response;
     }
 
-    private Object
+    protected Object
     responseCallList(Parcel p) {
         int num;
         int voiceSettings;
@@ -3797,7 +3801,7 @@ public final class RIL extends BaseCommands implements CommandsInterface {
         return response;
     }
 
-    private DataCallResponse getDataCallResponse(Parcel p, int version) {
+    protected DataCallResponse getDataCallResponse(Parcel p, int version) {
         DataCallResponse dataCall = new DataCallResponse();
 
         dataCall.version = version;
@@ -3845,7 +3849,7 @@ public final class RIL extends BaseCommands implements CommandsInterface {
         return dataCall;
     }
 
-    private Object
+    protected Object
     responseDataCallList(Parcel p) {
         ArrayList<DataCallResponse> response;
 
@@ -3863,7 +3867,7 @@ public final class RIL extends BaseCommands implements CommandsInterface {
         return response;
     }
 
-    private Object
+    protected Object
     responseSetupDataCall(Parcel p) {
         int ver = p.readInt();
         int num = p.readInt();
@@ -3917,7 +3921,7 @@ public final class RIL extends BaseCommands implements CommandsInterface {
         return dataCall;
     }
 
-    private Object
+    protected Object
     responseOperatorInfos(Parcel p) {
         String strings[] = (String [])responseStrings(p);
         ArrayList<OperatorInfo> ret;
@@ -3942,7 +3946,7 @@ public final class RIL extends BaseCommands implements CommandsInterface {
         return ret;
     }
 
-    private Object
+    protected Object
     responseCellList(Parcel p) {
        int num, rssi;
        String location;
@@ -3970,7 +3974,7 @@ public final class RIL extends BaseCommands implements CommandsInterface {
        return response;
     }
 
-    private Object responseGetPreferredNetworkType(Parcel p) {
+    protected Object responseGetPreferredNetworkType(Parcel p) {
        int [] response = (int[]) responseInts(p);
 
        if (response.length >= 1) {
@@ -3982,7 +3986,7 @@ public final class RIL extends BaseCommands implements CommandsInterface {
        return response;
     }
 
-    private Object responseGmsBroadcastConfig(Parcel p) {
+    protected Object responseGmsBroadcastConfig(Parcel p) {
         int num;
         ArrayList<SmsBroadcastConfigInfo> response;
         SmsBroadcastConfigInfo info;
@@ -4004,7 +4008,7 @@ public final class RIL extends BaseCommands implements CommandsInterface {
         return response;
     }
 
-    private Object
+    protected Object
     responseCdmaBroadcastConfig(Parcel p) {
         int numServiceCategories;
         int response[];
@@ -4043,7 +4047,7 @@ public final class RIL extends BaseCommands implements CommandsInterface {
         return response;
     }
 
-    private Object
+    protected Object
     responseSignalStrength(Parcel p) {
         // Assume this is gsm, but doesn't matter as ServiceStateTracker
         // sets the proper value.
@@ -4051,7 +4055,7 @@ public final class RIL extends BaseCommands implements CommandsInterface {
         return signalStrength;
     }
 
-    private ArrayList<CdmaInformationRecords>
+    protected ArrayList<CdmaInformationRecords>
     responseCdmaInformationRecord(Parcel p) {
         int numberOfInfoRecs;
         ArrayList<CdmaInformationRecords> response;
@@ -4071,7 +4075,7 @@ public final class RIL extends BaseCommands implements CommandsInterface {
         return response;
     }
 
-    private Object
+    protected Object
     responseCdmaCallWaiting(Parcel p) {
         CdmaCallWaitingNotification notification = new CdmaCallWaitingNotification();
 
@@ -4090,7 +4094,7 @@ public final class RIL extends BaseCommands implements CommandsInterface {
         return notification;
     }
 
-    private Object
+    protected Object
     responseCallRing(Parcel p){
         char response[] = new char[4];
 
@@ -4104,7 +4108,7 @@ public final class RIL extends BaseCommands implements CommandsInterface {
         return response;
     }
 
-    private void
+    protected void
     notifyRegistrantsCdmaInfoRec(CdmaInformationRecords infoRec) {
         int response = RIL_UNSOL_CDMA_INFO_REC;
         if (infoRec.record instanceof CdmaInformationRecords.CdmaDisplayInfoRec) {
@@ -4152,7 +4156,7 @@ public final class RIL extends BaseCommands implements CommandsInterface {
         }
     }
 
-    private ArrayList<CellInfo> responseCellInfoList(Parcel p) {
+    protected ArrayList<CellInfo> responseCellInfoList(Parcel p) {
         int numberOfInfoRecs;
         ArrayList<CellInfo> response;
 
@@ -4171,7 +4175,7 @@ public final class RIL extends BaseCommands implements CommandsInterface {
         return response;
     }
 
-   private Object
+   protected Object
    responseHardwareConfig(Parcel p) {
       int num;
       ArrayList<HardwareConfig> response;
@@ -4209,7 +4213,7 @@ public final class RIL extends BaseCommands implements CommandsInterface {
       return response;
    }
 
-    private Object
+    protected Object
     responseRadioCapability(Parcel p) {
         int version = p.readInt();
         int session = p.readInt();
@@ -4229,7 +4233,7 @@ public final class RIL extends BaseCommands implements CommandsInterface {
         return rc;
     }
 
-    private Object responseLceData(Parcel p) {
+    protected Object responseLceData(Parcel p) {
         final ArrayList<Integer> capacityResponse = new ArrayList<Integer>();
         final int capacityDownKbps = p.readInt();
         final int confidenceLevel = p.readByte();
@@ -4246,7 +4250,7 @@ public final class RIL extends BaseCommands implements CommandsInterface {
         return capacityResponse;
     }
 
-    private Object responseLceStatus(Parcel p) {
+    protected Object responseLceStatus(Parcel p) {
         final ArrayList<Integer> statusResponse = new ArrayList<Integer>();
         final int lceStatus = (int)p.readByte();
         final int actualInterval = p.readInt();
@@ -4259,7 +4263,7 @@ public final class RIL extends BaseCommands implements CommandsInterface {
         return statusResponse;
     }
 
-    private Object responseActivityData(Parcel p) {
+    protected Object responseActivityData(Parcel p) {
         final int sleepModeTimeMs = p.readInt();
         final int idleModeTimeMs = p.readInt();
         int [] txModeTimeMs = new int[ModemActivityInfo.TX_POWER_LEVELS];
@@ -4488,29 +4492,29 @@ public final class RIL extends BaseCommands implements CommandsInterface {
         }
     }
 
-    private void riljLog(String msg) {
+    protected void riljLog(String msg) {
         Rlog.d(RILJ_LOG_TAG, msg
                 + (mInstanceId != null ? (" [SUB" + mInstanceId + "]") : ""));
     }
 
-    private void riljLogv(String msg) {
+    protected void riljLogv(String msg) {
         Rlog.v(RILJ_LOG_TAG, msg
                 + (mInstanceId != null ? (" [SUB" + mInstanceId + "]") : ""));
     }
 
-    private void unsljLog(int response) {
+    protected void unsljLog(int response) {
         riljLog("[UNSL]< " + responseToString(response));
     }
 
-    private void unsljLogMore(int response, String more) {
+    protected void unsljLogMore(int response, String more) {
         riljLog("[UNSL]< " + responseToString(response) + " " + more);
     }
 
-    private void unsljLogRet(int response, Object ret) {
+    protected void unsljLogRet(int response, Object ret) {
         riljLog("[UNSL]< " + responseToString(response) + " " + retToString(response, ret));
     }
 
-    private void unsljLogvRet(int response, Object ret) {
+    protected void unsljLogvRet(int response, Object ret) {
         riljLogv("[UNSL]< " + responseToString(response) + " " + retToString(response, ret));
     }
 
-- 
2.9.3


From 0bd1a9c0a82de12253d7719d597eaa1b228d64c5 Mon Sep 17 00:00:00 2001
From: Mike Kasick <mike@kasick.org>
Date: Sat, 14 Mar 2015 20:20:39 +0700
Subject: [PATCH 2/7] RILs: Eliminate repeated overrides of
 responseOperatorInfos.

- Add mQANElements field, default to 4 in RIL, use in responseOperatorInfos.
  This may be set to 5 in subclassed RIL constructors.

- Remove repeated overrides of responseOperatorInfos by subclassed RILs, as
  there's no logic change, just a disagreement as to whether the
  QUERY_AVAILABLE_NETWORKS response is an array with 4 or 5 per-network
  elements.

- Size OperatorInfo ArrayList appropriately in SemcRIL and SonyQualcommRIL.

Change-Id: I1254a670d8611f76aad13a6f197c67012c7d4c47
---
 src/java/com/android/internal/telephony/RIL.java | 13 +++++++++----
 1 file changed, 9 insertions(+), 4 deletions(-)

diff --git a/src/java/com/android/internal/telephony/RIL.java b/src/java/com/android/internal/telephony/RIL.java
index 699cf50..e4680e5 100644
--- a/src/java/com/android/internal/telephony/RIL.java
+++ b/src/java/com/android/internal/telephony/RIL.java
@@ -299,6 +299,11 @@ public class RIL extends BaseCommands implements CommandsInterface {
 
     private TelephonyEventLog mEventLog;
 
+    // Number of per-network elements expected in QUERY_AVAILABLE_NETWORKS's response.
+    // 4 elements is default, but many RILs actually return 5, making it impossible to
+    // divide the response array without prior knowledge of the number of elements.
+    protected int mQANElements = 4;
+
     //***** Events
 
     static final int EVENT_SEND                 = 1;
@@ -3926,15 +3931,15 @@ public class RIL extends BaseCommands implements CommandsInterface {
         String strings[] = (String [])responseStrings(p);
         ArrayList<OperatorInfo> ret;
 
-        if (strings.length % 4 != 0) {
+        if (strings.length % mQANElements != 0) {
             throw new RuntimeException(
                 "RIL_REQUEST_QUERY_AVAILABLE_NETWORKS: invalid response. Got "
-                + strings.length + " strings, expected multible of 4");
+                + strings.length + " strings, expected multiple of " + mQANElements);
         }
 
-        ret = new ArrayList<OperatorInfo>(strings.length / 4);
+        ret = new ArrayList<OperatorInfo>(strings.length / mQANElements);
 
-        for (int i = 0 ; i < strings.length ; i += 4) {
+        for (int i = 0 ; i < strings.length ; i += mQANElements) {
             ret.add (
                 new OperatorInfo(
                     strings[i+0],
-- 
2.9.3


From e57e7ce5201edd3b2a4859f56707d39f7d1acc3c Mon Sep 17 00:00:00 2001
From: Pawit Pornkitprasan <p.pawit@gmail.com>
Date: Sun, 28 Dec 2014 18:53:11 +0700
Subject: [PATCH 3/7] UiccController: use registerForAvailable only for
 persist.radio.apm_sim_not_pwdn

Some QCOM RILs allow the SIM to be loaded in airplane mode, thus
CAF changed the callback to registerForAvailable, but that does
not work on other RILs where the SIM information will not be
loaded successfully.

Change-Id: I9f9124417db2fe983e716a2825fc08d87511f8aa
---
 src/java/com/android/internal/telephony/uicc/UiccController.java | 5 ++++-
 1 file changed, 4 insertions(+), 1 deletion(-)

diff --git a/src/java/com/android/internal/telephony/uicc/UiccController.java b/src/java/com/android/internal/telephony/uicc/UiccController.java
index 4f3b58b..30b5edf 100644
--- a/src/java/com/android/internal/telephony/uicc/UiccController.java
+++ b/src/java/com/android/internal/telephony/uicc/UiccController.java
@@ -122,7 +122,10 @@ public class UiccController extends Handler {
             Integer index = new Integer(i);
             mCis[i].registerForIccStatusChanged(this, EVENT_ICC_STATUS_CHANGED, index);
             // TODO remove this once modem correctly notifies the unsols
-            if (DECRYPT_STATE.equals(SystemProperties.get("vold.decrypt"))) {
+            if (DECRYPT_STATE.equals(SystemProperties.get("vold.decrypt")) ||
+                    SystemProperties.getBoolean("persist.radio.apm_sim_not_pwdn", false)) {
+                // Reading ICC status in airplane mode is only supported in QCOM
+                // RILs when this property is set to true
                 mCis[i].registerForAvailable(this, EVENT_ICC_STATUS_CHANGED, index);
             } else {
                 mCis[i].registerForOn(this, EVENT_ICC_STATUS_CHANGED, index);
-- 
2.9.3


From 156a76de59c659bd6f0251bf980b827c1143570d Mon Sep 17 00:00:00 2001
From: Arne Coucheron <arco68@gmail.com>
Date: Thu, 24 Mar 2016 20:56:34 +0100
Subject: [PATCH 4/7] Use registerForAvailable when device is encrypted only
 for RIL version >= 9

On older RIL versions, registerForAvailable causes the sim to not
being detected. We fixed this for non-encrypted state, but missed it
for encrypted state.

Change-Id: I26cca33c10edcbcb8ea10daaa6104eed910354bd
---
 src/java/com/android/internal/telephony/uicc/UiccController.java | 6 ++++--
 1 file changed, 4 insertions(+), 2 deletions(-)

diff --git a/src/java/com/android/internal/telephony/uicc/UiccController.java b/src/java/com/android/internal/telephony/uicc/UiccController.java
index 30b5edf..213d727 100644
--- a/src/java/com/android/internal/telephony/uicc/UiccController.java
+++ b/src/java/com/android/internal/telephony/uicc/UiccController.java
@@ -118,12 +118,14 @@ public class UiccController extends Handler {
         if (DBG) log("Creating UiccController");
         mContext = c;
         mCis = ci;
+        boolean radioApmSimNotPwdn = SystemProperties.getBoolean(
+                "persist.radio.apm_sim_not_pwdn", false);
         for (int i = 0; i < mCis.length; i++) {
             Integer index = new Integer(i);
             mCis[i].registerForIccStatusChanged(this, EVENT_ICC_STATUS_CHANGED, index);
             // TODO remove this once modem correctly notifies the unsols
-            if (DECRYPT_STATE.equals(SystemProperties.get("vold.decrypt")) ||
-                    SystemProperties.getBoolean("persist.radio.apm_sim_not_pwdn", false)) {
+            if ((DECRYPT_STATE.equals(SystemProperties.get("vold.decrypt")) &&
+                    mCis[i].getRilVersion() >= 9) || radioApmSimNotPwdn) {
                 // Reading ICC status in airplane mode is only supported in QCOM
                 // RILs when this property is set to true
                 mCis[i].registerForAvailable(this, EVENT_ICC_STATUS_CHANGED, index);
-- 
2.9.3


From f230cfbe4bc3942351e8dc71bdb86a14572a8fe0 Mon Sep 17 00:00:00 2001
From: Pawit Pornkitprasan <p.pawit@gmail.com>
Date: Wed, 17 Dec 2014 21:19:34 +0700
Subject: [PATCH 5/7] Forward port Samsung STK support
 (frameworks/opt/telephony)
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Squashed commit of the following:

commit 7940f7ced44976f03171d09c2ba8b1d29bc9432e
Author: Flamefire <alex@grundis.de>
Date:   Sat Nov 15 21:26:33 2014 +0100

    Fix crash of Samsung phones

    Using an alternative SMS app like chompSMS leads to a crash as
    sendResult is an array without any entries (sendResult[0] is accessed)
    The default SMS app does not show this because mCurrntCmd == null

    Change-Id: Icfef6d20f9082dd1f64ed29b67031d2575896513

commit ed0cac138315b4dd5b36c35651ba6d23f1a47ae0
Author: Pawit Pornkitprasan <p.pawit@gmail.com>
Date:   Tue Dec 11 17:22:30 2012 +0700

    Samsung STK: Fix SMS-based STK

    SEND_SMS was falling through to SEND_USSD (which used to do nothing
    until USSD support was added) causing an Exception because cmdParams
    is not an instance of SendUSSDParams.

    Fix by using type-checking instead of checking if Samsung STK is
    enabled (because SendSMSParams and SendUSSDParams will only be
    created if Samsung STK is enabled.)

    Change-Id: I671014e295e9e529aad25a8b6fbd5a2e5788fc44

commit 7a9f16293abc6e216004d0c80822d39dac98db98
Author: Pawit Pornkitprasan <p.pawit@gmail.com>
Date:   Fri Nov 30 21:35:50 2012 +0700

    Samsung STK: Add USSD support

    Allow USSD-based STK applications to work

    Change-Id: I483f37a44a6c3ed43eefcf979e17b84877d03f93

commit b5ade3b5a527193ffc6e71f6ce55d3a96a83792a
Author: Pawit Pornkitprasan <p.pawit@gmail.com>
Date:   Fri Nov 30 19:30:08 2012 +0700

    Add Samsung STK support (telephony part)

    Support for SMS-based SIM applications.
    Partially rewritten the original patch by JÃ¼ri Schultz to be less intrusive.

    Change-Id: I15d2de1781a2823e24941dd792db3d372578aa9f

Change-Id: I476959cfadab0ab14f5ed32adf51adca1e3b26b4
---
 .../android/internal/telephony/BaseCommands.java   |  10 ++
 .../internal/telephony/CommandsInterface.java      |  12 ++
 .../internal/telephony/cat/CallControlResult.java  |  44 +++++++
 .../android/internal/telephony/cat/CatService.java | 133 +++++++++++++++++++++
 .../internal/telephony/cat/CommandParams.java      |  21 ++++
 .../telephony/cat/CommandParamsFactory.java        |  42 ++++++-
 .../internal/telephony/cat/ValueParser.java        | 101 ++++++++++++++++
 .../telephony/test/SimulatedCommandsVerifier.java  |  10 ++
 8 files changed, 372 insertions(+), 1 deletion(-)
 create mode 100644 src/java/com/android/internal/telephony/cat/CallControlResult.java

diff --git a/src/java/com/android/internal/telephony/BaseCommands.java b/src/java/com/android/internal/telephony/BaseCommands.java
index b95b4f3..9a03677 100644
--- a/src/java/com/android/internal/telephony/BaseCommands.java
+++ b/src/java/com/android/internal/telephony/BaseCommands.java
@@ -86,6 +86,7 @@ public abstract class BaseCommands implements CommandsInterface {
     protected Registrant mCatProCmdRegistrant;
     protected Registrant mCatEventRegistrant;
     protected Registrant mCatCallSetUpRegistrant;
+    protected Registrant mCatSendSmsResultRegistrant;
     protected Registrant mIccSmsFullRegistrant;
     protected Registrant mEmergencyCallbackModeRegistrant;
     protected Registrant mRingRegistrant;
@@ -449,6 +450,15 @@ public abstract class BaseCommands implements CommandsInterface {
         }
     }
 
+    // For Samsung STK
+    public void setOnCatSendSmsResult(Handler h, int what, Object obj) {
+        mCatSendSmsResultRegistrant = new Registrant(h, what, obj);
+    }
+
+    public void unSetOnCatSendSmsResult(Handler h) {
+        mCatSendSmsResultRegistrant.clear();
+    }
+
     @Override
     public void setOnIccSmsFull(Handler h, int what, Object obj) {
         mIccSmsFullRegistrant = new Registrant (h, what, obj);
diff --git a/src/java/com/android/internal/telephony/CommandsInterface.java b/src/java/com/android/internal/telephony/CommandsInterface.java
index 3819953..938bde3 100644
--- a/src/java/com/android/internal/telephony/CommandsInterface.java
+++ b/src/java/com/android/internal/telephony/CommandsInterface.java
@@ -2017,4 +2017,16 @@ public interface CommandsInterface {
      * @param result Callback message contains the modem activity information
      */
     public void getModemActivityInfo(Message result);
+
+    /**
+     * @hide
+     * samsung stk service implementation - set up registrant for sending
+     * sms send result from modem(RIL) to catService
+     */
+    void setOnCatSendSmsResult(Handler h, int what, Object obj);
+
+    /**
+     * @hide
+     */
+    void unSetOnCatSendSmsResult(Handler h);
 }
diff --git a/src/java/com/android/internal/telephony/cat/CallControlResult.java b/src/java/com/android/internal/telephony/cat/CallControlResult.java
new file mode 100644
index 0000000..2dbc0d4
--- /dev/null
+++ b/src/java/com/android/internal/telephony/cat/CallControlResult.java
@@ -0,0 +1,44 @@
+/*
+ * Copyright (C) 2007 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.internal.telephony.cat;
+
+
+public enum CallControlResult {
+
+    CALL_CONTROL_NO_CONTROL(0x00),
+    CALL_CONTROL_ALLOWED_NO_MOD(0x01),
+    CALL_CONTROL_NOT_ALLOWED(0x02),
+    CALL_CONTROL_ALLOWED_WITH_MOD(0x03);
+    private int mValue;
+
+    CallControlResult(int value) {
+        mValue = value;
+    }
+
+    public static CallControlResult fromInt(int value) {
+        for (CallControlResult e : CallControlResult.values()) {
+            if (e.mValue == value) {
+                return e;
+            }
+        }
+        return null;
+    }
+
+    public int value() {
+        return mValue;
+    }
+}
diff --git a/src/java/com/android/internal/telephony/cat/CatService.java b/src/java/com/android/internal/telephony/cat/CatService.java
index be691c5..04e90c3 100644
--- a/src/java/com/android/internal/telephony/cat/CatService.java
+++ b/src/java/com/android/internal/telephony/cat/CatService.java
@@ -95,6 +95,10 @@ public class CatService extends Handler implements AppInterface {
     private UiccController mUiccController;
     private CardState mCardState = CardState.CARDSTATE_ABSENT;
 
+    // Samsung STK
+    private int mTimeoutDest = 0;
+    private int mCallControlResultCode = 0;
+
     // Service constants.
     protected static final int MSG_ID_SESSION_END              = 1;
     protected static final int MSG_ID_PROACTIVE_COMMAND        = 2;
@@ -108,6 +112,8 @@ public class CatService extends Handler implements AppInterface {
     protected static final int MSG_ID_ALPHA_NOTIFY   = 9;
 
     static final int MSG_ID_RIL_MSG_DECODED          = 10;
+    static final int MSG_ID_TIMEOUT                  = 11; // Samsung STK
+    static final int MSG_ID_SEND_SMS_RESULT          = 12; // Samsung STK
 
     // Events to signal SIM presence or absent in the device.
     private static final int MSG_ID_ICC_RECORDS_LOADED       = 20;
@@ -126,6 +132,14 @@ public class CatService extends Handler implements AppInterface {
     private HandlerThread mHandlerThread;
     private int mSlotId;
 
+    // Samsung STK SEND_SMS
+    static final int WAITING_SMS_RESULT = 2;
+    static final int WAITING_SMS_RESULT_TIME = 60000;
+
+    static final int SMS_SEND_OK = 0;
+    static final int SMS_SEND_FAIL = 32790;
+    static final int SMS_SEND_RETRY = 32810;
+
     /* For multisim catservice should not be singleton */
     private CatService(CommandsInterface ci, UiccCardApplication ca, IccRecords ir,
             Context context, IccFileHandler fh, UiccCard ic, int slotId) {
@@ -153,6 +167,7 @@ public class CatService extends Handler implements AppInterface {
         mCmdIf.setOnCatProactiveCmd(this, MSG_ID_PROACTIVE_COMMAND, null);
         mCmdIf.setOnCatEvent(this, MSG_ID_EVENT_NOTIFY, null);
         mCmdIf.setOnCatCallSetUp(this, MSG_ID_CALL_SETUP, null);
+        mCmdIf.setOnCatSendSmsResult(this, MSG_ID_SEND_SMS_RESULT, null); // Samsung STK
         //mCmdIf.setOnSimRefresh(this, MSG_ID_REFRESH, null);
 
         mCmdIf.registerForIccRefresh(this, MSG_ID_ICC_REFRESH, null);
@@ -246,6 +261,7 @@ public class CatService extends Handler implements AppInterface {
             mCmdIf.unSetOnCatEvent(this);
             mCmdIf.unSetOnCatCallSetUp(this);
             mCmdIf.unSetOnCatCcAlphaNotify(this);
+            mCmdIf.unSetOnCatSendSmsResult(this);
 
             mCmdIf.unregisterForIccRefresh(this);
             if (mUiccController != null) {
@@ -433,8 +449,17 @@ public class CatService extends Handler implements AppInterface {
                 break;
             case SEND_DTMF:
             case SEND_SMS:
+                // Samsung STK
+                if (cmdParams instanceof SendSMSParams) {
+                    handleProactiveCommandSendSMS((SendSMSParams) cmdParams);
+                }
+                // Fall through
             case SEND_SS:
             case SEND_USSD:
+                // Samsung STK
+                if (cmdParams instanceof SendUSSDParams) {
+                    handleProactiveCommandSendUSSD((SendUSSDParams) cmdParams);
+                }
                 if ((((DisplayTextParams)cmdParams).mTextMsg.text != null)
                         && (((DisplayTextParams)cmdParams).mTextMsg.text.equals(STK_DEFAULT))) {
                     message = mContext.getText(com.android.internal.R.string.sending);
@@ -854,6 +879,82 @@ public class CatService extends Handler implements AppInterface {
                 CatLog.d(this, "CAT Alpha message: msg.obj is null");
             }
             break;
+        case MSG_ID_TIMEOUT: // Should only be called for Samsung STK
+            if (mTimeoutDest == WAITING_SMS_RESULT) {
+                CatLog.d(this, "SMS SEND TIMEOUT");
+                if (CallControlResult.fromInt(mCallControlResultCode) ==
+                        CallControlResult.CALL_CONTROL_NOT_ALLOWED) {
+                    sendTerminalResponse(mCurrntCmd.mCmdDet,
+                            ResultCode.USIM_CALL_CONTROL_PERMANENT, true, 1, null);
+                } else {
+                    sendTerminalResponse(mCurrntCmd.mCmdDet,
+                            ResultCode.TERMINAL_CRNTLY_UNABLE_TO_PROCESS, false, 0, null);
+                }
+            }
+            break;
+        case MSG_ID_SEND_SMS_RESULT: // Samsung STK SEND_SMS
+            if (mContext.getResources().
+                        getBoolean(com.android.internal.R.bool.config_samsung_stk)) {
+                int[] sendResult;
+                AsyncResult ar;
+                CatLog.d(this, "handleMsg : MSG_ID_SEND_SMS_RESULT");
+                cancelTimeOut();
+                CatLog.d(this, "The Msg ID data:" + msg.what);
+                ar = (AsyncResult) msg.obj;
+                if (ar == null || ar.result == null || mCurrntCmd == null || mCurrntCmd.mCmdDet == null) {
+                    break;
+                }
+                sendResult = (int[]) ar.result;
+                if (sendResult.length == 0) {
+                    break;
+                }
+                switch (sendResult[0]) {
+                    default:
+                        CatLog.d(this, "SMS SEND GENERIC FAIL");
+                        if (CallControlResult.fromInt(mCallControlResultCode) ==
+                                CallControlResult.CALL_CONTROL_NOT_ALLOWED) {
+                            sendTerminalResponse(mCurrntCmd.mCmdDet,
+                                    ResultCode.USIM_CALL_CONTROL_PERMANENT, true, 1, null);
+                        } else {
+                            sendTerminalResponse(mCurrntCmd.mCmdDet,
+                                    ResultCode.TERMINAL_CRNTLY_UNABLE_TO_PROCESS, false, 0, null);
+                        }
+                        break;
+                    case SMS_SEND_OK: // '\0'
+                        CatLog.d(this, "SMS SEND OK");
+                        if (CallControlResult.fromInt(mCallControlResultCode) ==
+                                CallControlResult.CALL_CONTROL_NOT_ALLOWED) {
+                            sendTerminalResponse(mCurrntCmd.mCmdDet,
+                                    ResultCode.USIM_CALL_CONTROL_PERMANENT, true, 1, null);
+                        } else {
+                            sendTerminalResponse(mCurrntCmd.mCmdDet, ResultCode.OK, false, 0, null);
+                        }
+                        break;
+                    case SMS_SEND_FAIL:
+                        CatLog.d(this, "SMS SEND FAIL - MEMORY NOT AVAILABLE");
+                        if (CallControlResult.fromInt(mCallControlResultCode) ==
+                                CallControlResult.CALL_CONTROL_NOT_ALLOWED) {
+                            sendTerminalResponse(mCurrntCmd.mCmdDet,
+                                    ResultCode.USIM_CALL_CONTROL_PERMANENT, true, 1, null);
+                        } else {
+                            sendTerminalResponse(mCurrntCmd.mCmdDet,
+                                    ResultCode.TERMINAL_CRNTLY_UNABLE_TO_PROCESS, false, 0, null);
+                        }
+                        break;
+                    case SMS_SEND_RETRY:
+                        CatLog.d(this, "SMS SEND FAIL RETRY");
+                        if (CallControlResult.fromInt(mCallControlResultCode) ==
+                                CallControlResult.CALL_CONTROL_NOT_ALLOWED) {
+                            sendTerminalResponse(mCurrntCmd.mCmdDet,
+                                    ResultCode.USIM_CALL_CONTROL_PERMANENT, true, 1, null);
+                        } else {
+                            sendTerminalResponse(mCurrntCmd.mCmdDet,
+                                    ResultCode.NETWORK_CRNTLY_UNABLE_TO_PROCESS, false, 0, null);
+                        }
+                        break;
+                    }
+            }
+            break;
         default:
             throw new AssertionError("Unrecognized CAT command: " + msg.what);
         }
@@ -1118,4 +1219,36 @@ public class CatService extends Handler implements AppInterface {
             mCmdIf.reportStkServiceIsRunning(null);
         }
     }
+
+    /**
+     * Samsung STK SEND_SMS
+     * @param cmdPar
+     */
+    private void handleProactiveCommandSendSMS(SendSMSParams cmdPar) {
+        CatLog.d(this, "The smscaddress is: " + cmdPar.smscAddress);
+        CatLog.d(this, "The SMS tpdu is: " + cmdPar.pdu);
+        mCmdIf.sendSMS(cmdPar.smscAddress, cmdPar.pdu, null);
+        startTimeOut(WAITING_SMS_RESULT, WAITING_SMS_RESULT_TIME);
+    }
+
+    /**
+     * Samsung STK SEND_USSD
+     * @param cmdPar
+     */
+    private void handleProactiveCommandSendUSSD(SendUSSDParams cmdPar) {
+        CatLog.d(this, "The USSD is: " + cmdPar.ussdString);
+        mCmdIf.sendUSSD(cmdPar.ussdString, null);
+        // Sent USSD, let framework handle the rest
+    }
+
+    private void cancelTimeOut() {
+        removeMessages(MSG_ID_TIMEOUT);
+        mTimeoutDest = 0;
+    }
+
+    private void startTimeOut(int timeout, int delay) {
+        cancelTimeOut();
+        mTimeoutDest = timeout;
+        sendMessageDelayed(obtainMessage(MSG_ID_TIMEOUT), delay);
+    }
 }
diff --git a/src/java/com/android/internal/telephony/cat/CommandParams.java b/src/java/com/android/internal/telephony/cat/CommandParams.java
index 7dfedab..57fad97 100644
--- a/src/java/com/android/internal/telephony/cat/CommandParams.java
+++ b/src/java/com/android/internal/telephony/cat/CommandParams.java
@@ -224,3 +224,24 @@ class BIPClientParams extends CommandParams {
         return false;
     }
 }
+
+// Samsung STK
+class SendSMSParams extends DisplayTextParams {
+    String pdu;
+    String smscAddress;
+
+    SendSMSParams(CommandDetails cmdDet, TextMessage textmessage, String smscaddress, String smsPdu) {
+        super(cmdDet, textmessage);
+        smscAddress = smscaddress;
+        pdu = smsPdu;
+    }
+}
+
+class SendUSSDParams extends DisplayTextParams {
+    String ussdString;
+
+    SendUSSDParams(CommandDetails cmdDet, TextMessage textmessage, String ussdstring) {
+        super(cmdDet, textmessage);
+        ussdString = ussdstring;
+    }
+}
diff --git a/src/java/com/android/internal/telephony/cat/CommandParamsFactory.java b/src/java/com/android/internal/telephony/cat/CommandParamsFactory.java
index 2990da3..b56ffe7 100755
--- a/src/java/com/android/internal/telephony/cat/CommandParamsFactory.java
+++ b/src/java/com/android/internal/telephony/cat/CommandParamsFactory.java
@@ -16,6 +16,7 @@
 
 package com.android.internal.telephony.cat;
 
+import android.content.res.Resources;
 import android.graphics.Bitmap;
 import android.os.Handler;
 import android.os.Message;
@@ -717,7 +718,46 @@ class CommandParamsFactory extends Handler {
         }
 
         textMsg.responseNeeded = false;
-        mCmdParams = new DisplayTextParams(cmdDet, textMsg);
+        // Samsung STK
+        if (Resources.getSystem().getBoolean(com.android.internal.R.bool.config_samsung_stk)) {
+            AppInterface.CommandType cmdType = AppInterface.CommandType.fromInt(cmdDet.typeOfCommand);
+            if (cmdType == AppInterface.CommandType.SEND_SMS) {
+                String smscAddress = null;
+                String pdu = null;
+
+                ctlv = searchForTag(ComprehensionTlvTag.ADDRESS, ctlvs);
+                if (ctlv != null) {
+                    smscAddress = ValueParser.retrieveSMSCaddress(ctlv);
+                    CatLog.d(this, "The smsc address is " + smscAddress);
+                } else {
+                    CatLog.d(this, "The smsc address is null");
+                }
+
+                ctlv = searchForTag(ComprehensionTlvTag.SMS_TPDU, ctlvs);
+                if (ctlv != null) {
+                    pdu = ValueParser.retrieveSMSTPDU(ctlv);
+                    CatLog.d(this, "The SMS tpdu is " + pdu);
+                } else {
+                    CatLog.d(this, "The SMS tpdu is null");
+                }
+                mCmdParams = new SendSMSParams(cmdDet, textMsg, smscAddress, pdu);
+            } else if (cmdType == AppInterface.CommandType.SEND_USSD) {
+                String ussdString = null;
+
+                ctlv = searchForTag(ComprehensionTlvTag.USSD_STRING, ctlvs);
+                if (ctlv != null) {
+                    ussdString = ValueParser.retrieveUSSDString(ctlv);
+                    CatLog.d(this, "The ussd string is " + ussdString);
+                } else {
+                    CatLog.d(this, "The ussd string is null");
+                }
+                mCmdParams = new SendUSSDParams(cmdDet, textMsg, ussdString);
+            } else {
+                mCmdParams = new DisplayTextParams(cmdDet, textMsg);
+            }
+        } else {
+            mCmdParams = new DisplayTextParams(cmdDet, textMsg);
+        }
 
         if (iconId != null) {
             mloadIcon = true;
diff --git a/src/java/com/android/internal/telephony/cat/ValueParser.java b/src/java/com/android/internal/telephony/cat/ValueParser.java
index 91a6fd6..d753659 100644
--- a/src/java/com/android/internal/telephony/cat/ValueParser.java
+++ b/src/java/com/android/internal/telephony/cat/ValueParser.java
@@ -354,4 +354,105 @@ abstract class ValueParser {
             throw new ResultException(ResultCode.CMD_DATA_NOT_UNDERSTOOD);
         }
     }
+
+    /**
+     * Samsung STK: Read SMSC Address
+     *
+     * @param ctlv A SMSC Address COMPREHENSION-TLV object
+     * @return A Java String object decoded from the SMSC Address object
+     * @throws ResultException
+     */
+    static String retrieveSMSCaddress(ComprehensionTlv ctlv)
+        throws ResultException {
+        byte[] rawValue = ctlv.getRawValue();
+        int valueIndex = ctlv.getValueIndex();
+        int length = ctlv.getLength();
+        byte[] outputValue = new byte[length + 1];
+
+        for (int k = 0; k <= length; k++) {
+            try {
+                outputValue[k] = rawValue[k + (valueIndex - 1)];
+            } catch (IndexOutOfBoundsException indexoutofboundsexception) {
+                throw new ResultException(ResultCode.CMD_DATA_NOT_UNDERSTOOD);
+            }
+        }
+        if (length != 0) {
+            return IccUtils.bytesToHexString(outputValue);
+        } else {
+            throw new ResultException(ResultCode.CMD_DATA_NOT_UNDERSTOOD);
+        }
+    }
+
+    /**
+     * Samsung STK: Read SMS TPDU Address
+     *
+     * @param ctlv A SMS TPDU COMPREHENSION-TLV object
+     * @return A Java String object decoded from the SMS TPDU object
+     * @throws ResultException
+     */
+    static String retrieveSMSTPDU(ComprehensionTlv ctlv)
+            throws ResultException {
+        byte[] rawValue = ctlv.getRawValue();
+        int valueIndex = ctlv.getValueIndex();
+        int pduLength = ctlv.getLength();
+        byte[] outputValue;
+        int k;
+        String result;
+        if (rawValue[valueIndex + 2] % 2 == 0) {
+            k = rawValue[valueIndex + 2] / 2;
+        } else {
+            k = (1 + rawValue[valueIndex + 2]) / 2;
+        }
+
+        if (pduLength == k + 6) {
+            outputValue = new byte[pduLength + 1];
+        } else {
+            outputValue = new byte[pduLength];
+        }
+
+        for (int l = 0; l < pduLength; l++) {
+            try {
+                outputValue[l] = rawValue[valueIndex + l];
+            } catch (IndexOutOfBoundsException ex) {
+                throw new ResultException(ResultCode.CMD_DATA_NOT_UNDERSTOOD);
+            }
+        }
+        if (pduLength != 0) {
+            result = IccUtils.bytesToHexString(outputValue);
+        } else {
+            throw new ResultException(ResultCode.CMD_DATA_NOT_UNDERSTOOD);
+        }
+
+        return result;
+    }
+
+    /**
+     * Samsung STK: Read USSD String
+     *
+     * @param ctlv A USSD String COMPREHENSION-TLV object
+     * @return A String object decoded from the USSD String object
+     * @throws ResultException
+     */
+    static String retrieveUSSDString(ComprehensionTlv ctlv) throws ResultException {
+        byte[] rawValue = ctlv.getRawValue();
+        int valueIndex = ctlv.getValueIndex();
+        int length = ctlv.getLength();
+
+        // If length is 0 (shouldn't be), return null
+        if (length == 0) {
+            return null;
+        }
+
+        // Should be 0x0f
+        if (rawValue[valueIndex] != 0x0f) {
+            throw new ResultException(ResultCode.CMD_DATA_NOT_UNDERSTOOD);
+        }
+
+        try {
+            return GsmAlphabet.gsm7BitPackedToString(rawValue,
+                    valueIndex + 1, ((length - 1) * 8) / 7);
+        } catch (IndexOutOfBoundsException e) {
+            throw new ResultException(ResultCode.CMD_DATA_NOT_UNDERSTOOD);
+        }
+    }
 }
diff --git a/src/java/com/android/internal/telephony/test/SimulatedCommandsVerifier.java b/src/java/com/android/internal/telephony/test/SimulatedCommandsVerifier.java
index 11f6d4a..4ca9747 100644
--- a/src/java/com/android/internal/telephony/test/SimulatedCommandsVerifier.java
+++ b/src/java/com/android/internal/telephony/test/SimulatedCommandsVerifier.java
@@ -1350,4 +1350,14 @@ public class SimulatedCommandsVerifier implements CommandsInterface {
     public void getModemActivityInfo(Message result) {
 
     }
+ 
+    @Override
+    public void setOnCatSendSmsResult(Handler h, int what, Object obj) {
+
+    }
+
+    @Override
+    public void unSetOnCatSendSmsResult(Handler h) {
+
+    }
 }
-- 
2.9.3


From 6d273a46e72339182364ae42becd7ff069ecab1c Mon Sep 17 00:00:00 2001
From: Pawit Pornkitprasan <p.pawit@gmail.com>
Date: Sat, 31 May 2014 12:34:56 +0700
Subject: [PATCH 6/7] telephony: support for RIL that does not send
 UNSOL_CALL_RING

Samsung Broadcom RIL does not send UNSOL_CALL_RING at all, so it
needs to be faked or non loop (e.g. Digital Phone) ringtones
won't work.

Change-Id: Ib7373d32777f6c42ee488972a7aa63ae8e1cd09b
---
 src/java/com/android/internal/telephony/Phone.java | 19 +++++++++++++++++++
 1 file changed, 19 insertions(+)

diff --git a/src/java/com/android/internal/telephony/Phone.java b/src/java/com/android/internal/telephony/Phone.java
index ac284e0..2c3b453 100644
--- a/src/java/com/android/internal/telephony/Phone.java
+++ b/src/java/com/android/internal/telephony/Phone.java
@@ -223,6 +223,7 @@ public abstract class Phone extends Handler implements PhoneInternalInterface {
     private boolean mDnsCheckDisabled;
     public DcTracker mDcTracker;
     private boolean mDoesRilSendMultipleCallRing;
+    private boolean mDoesRilSendCallRing;
     private int mCallRingContinueToken;
     private int mCallRingDelay;
     private boolean mIsVoiceCapable = true;
@@ -461,6 +462,11 @@ public abstract class Phone extends Handler implements PhoneInternalInterface {
                 TelephonyProperties.PROPERTY_RIL_SENDS_MULTIPLE_CALL_RING, true);
         Rlog.d(LOG_TAG, "mDoesRilSendMultipleCallRing=" + mDoesRilSendMultipleCallRing);
 
+        // Some RIL do not even send a single RIL_UNSOL_CALL_RING
+        mDoesRilSendCallRing = SystemProperties.getBoolean(
+                "ro.telephony.call_ring", true);
+        Rlog.d(LOG_TAG, "mDoesRilSendCallRing=" + mDoesRilSendCallRing);
+
         mCallRingDelay = SystemProperties.getInt(
                 TelephonyProperties.PROPERTY_CALL_RING_DELAY, 3000);
         Rlog.d(LOG_TAG, "mCallRingDelay=" + mCallRingDelay);
@@ -2625,6 +2631,18 @@ public abstract class Phone extends Handler implements PhoneInternalInterface {
     public void notifyNewRingingConnectionP(Connection cn) {
         if (!mIsVoiceCapable)
             return;
+
+        // Fake RIL_UNSOL_CALL_RING if the RIL doesn't send it.
+        // Note that we need the delay to prevent the request from
+        // being sent after CallTracker detects "RINGING" state, but
+        // before the correct contact-specific ringtone is queried.
+        // Otherwise, the incorrect ringtone will be used
+        if (!mDoesRilSendCallRing) {
+            int token = ++mCallRingContinueToken;
+            sendMessageDelayed(
+                    obtainMessage(EVENT_CALL_RING_CONTINUE, token, 0), mCallRingDelay);
+        }
+
         AsyncResult ar = new AsyncResult(null, cn, null);
         mNewRingingConnectionRegistrants.notifyRegistrants(ar);
     }
@@ -3261,6 +3279,7 @@ public abstract class Phone extends Handler implements PhoneInternalInterface {
         pw.println(" mDnsCheckDisabled=" + mDnsCheckDisabled);
         pw.println(" mDcTracker=" + mDcTracker);
         pw.println(" mDoesRilSendMultipleCallRing=" + mDoesRilSendMultipleCallRing);
+        pw.println(" mDoesRilSendCallRing=" + mDoesRilSendCallRing);
         pw.println(" mCallRingContinueToken=" + mCallRingContinueToken);
         pw.println(" mCallRingDelay=" + mCallRingDelay);
         pw.println(" mIsVoiceCapable=" + mIsVoiceCapable);
-- 
2.9.3


From b88f100ef75dcb649571137ec10f81f66b7b28d5 Mon Sep 17 00:00:00 2001
From: Pawit Pornkitprasan <p.pawit@gmail.com>
Date: Sat, 15 Nov 2014 17:39:50 +0700
Subject: [PATCH 7/7] telephony: RIL: i9082: set correct rild names

Change-Id: Idf8e98ae2f36f30b84be04b7b062ca4b52cebd8a
---
 src/java/com/android/internal/telephony/RIL.java | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/java/com/android/internal/telephony/RIL.java b/src/java/com/android/internal/telephony/RIL.java
index e4680e5..f4a83fc 100644
--- a/src/java/com/android/internal/telephony/RIL.java
+++ b/src/java/com/android/internal/telephony/RIL.java
@@ -322,7 +322,7 @@ public class RIL extends BaseCommands implements CommandsInterface {
     static final int RESPONSE_SOLICITED_ACK_EXP = 3;
     static final int RESPONSE_UNSOLICITED_ACK_EXP = 4;
 
-    static final String[] SOCKET_NAME_RIL = {"rild", "rild2", "rild3"};
+    static final String[] SOCKET_NAME_RIL = {"rild", "rild1", "rild2"};
 
     static final int SOCKET_OPEN_RETRY_MILLIS = 4 * 1000;
 
-- 
2.9.3

